use crate::{QuirkSink, SValue};

/// Generated by [`SValue::q_as_bool`]
///
/// As Scratch blocks don't allow placing an expression block inside
/// of an comparison context
/// (block shapes, round blocks can't be placed in wholes of shape <..>)
/// this shouldn't occur for normal user programs.
pub enum SValueToBoolQ {
    /// Boolean conversion for empty string returned [false]
    EmptyStringTreatedAsFalse,
    /// Boolean conversion of a non-empty string returned [true]
    NonEmptyStringTreatedAsTrue,
    /// The integer or float number zero was converted to [false]
    ZeroToFalse,
    /// The integer or float number one was converted to [true]
    OneToTrue,
    /// An integer that was neither zero nor one was converted to [true]
    IntToBoolNotLossless(i64),
    /// A float that was neither zero nor one was converted to [true]
    FloatToBoolNotLossless(f64),
}

impl SValue {
    /// Converts the value to a boolean according to Scratch logic.
    ///
    /// | input             | associated boolean   |
    /// | :---------------- | :------------------- |
    /// | `""`              | `false`              |
    /// | `"false"`         | `false`              |
    /// | `"true"`          | `true`               |
    /// | Int 0 / Float 0.0 | `false`              |
    /// | Int 1 / Float 1.0 | `true`               |
    /// | other string      | `true`               |
    /// | other number      | `true`               |
    /// | already boolean   | _unchanged_          |
    ///
    /// Occuring behaviour differences Scratch implements to avoid errors
    /// will be reported to the sink.
    ///
    /// As expression blocks can't be placed in comparison contexts
    /// these quriks should never occur because of a user's program.
    ///
    /// For completness they are reported.
    pub fn q_as_bool<Q>(&self, sink: &mut Q) -> bool
    where
        Q: QuirkSink<SValueToBoolQ>,
    {
        match self {
            Self::Text(t) => {
                if t.as_ref() == "" {
                    sink.put(SValueToBoolQ::EmptyStringTreatedAsFalse);
                    false
                } else if t.as_ref() == "false" {
                    false
                } else if t.as_ref() == "true" {
                    true
                } else {
                    sink.put(SValueToBoolQ::NonEmptyStringTreatedAsTrue);
                    true
                }
            }
            Self::Bool(b) => *b,
            Self::Int(0) | Self::Float(0.0) => {
                sink.put(SValueToBoolQ::ZeroToFalse);
                false
            }
            Self::Int(1) | Self::Float(1.0) => {
                sink.put(SValueToBoolQ::OneToTrue);
                true
            }
            Self::Int(i) => {
                sink.put(SValueToBoolQ::IntToBoolNotLossless(*i));
                true
            }
            Self::Float(f) => {
                sink.put(SValueToBoolQ::FloatToBoolNotLossless(*f));
                true
            }
        }
    }
}
