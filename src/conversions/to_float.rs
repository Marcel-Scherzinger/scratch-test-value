use crate::{ARc, QuirkSink, SNumber, SValue};

/// Generated by [`SValue::q_as_float`]
pub enum SValueToFloatQ {
    /// [`true`] will be treated as (float) 1.0, [`false`] as (float) 0.0
    BoolNotANumber(bool),
    /// The text is converted to the (float) number 0.0
    TextNotANumber(ARc<str>),
    /// The stored integer has lost precision after converting it to a float
    IntToFloatNotLossless,
}

/// Generated by [`SNumber::q_as_float`]
pub enum SNumberToFloatQ {
    /// The stored integer has lost precision after converting it to a float
    IntToFloatNotLossless,
}

impl SValue {
    pub fn q_as_float<Q>(&self, sink: &mut Q) -> f64
    where
        Q: QuirkSink<SValueToFloatQ>,
    {
        match self {
            Self::Bool(b) => {
                sink.put(SValueToFloatQ::BoolNotANumber(*b));
                if *b { 1.0 } else { 0.0 }
            }
            Self::Text(t) => {
                if let Ok(f) = t.parse() {
                    f
                } else {
                    sink.put(SValueToFloatQ::TextNotANumber(t.clone()));
                    0.0
                }
            }
            Self::Int(i1) => {
                let f: f64 = (*i1) as f64;
                let i2 = f as i64;
                if *i1 != i2 {
                    sink.put(SValueToFloatQ::IntToFloatNotLossless);
                }
                f
            }
            Self::Float(f) => *f,
        }
    }
}
impl SNumber {
    pub fn q_as_float<Q>(&self, sink: &mut Q) -> f64
    where
        Q: QuirkSink<SNumberToFloatQ>,
    {
        match self {
            Self::Int(i1) => {
                let f: f64 = (*i1) as f64;
                let i2 = f as i64;
                if *i1 != i2 {
                    sink.put(SNumberToFloatQ::IntToFloatNotLossless);
                }
                f
            }
            Self::Float(f) => *f,
        }
    }
    /// internal convenience method that transforms the [`f64`] from
    /// [`Self::q_as_float`] to [`0`] if it was [`f64::NAN`]
    /// as many Scratch blocks treat [`f64::NAN`] as zero.
    pub(crate) fn q_as_float_nan_is_zero<Q>(&self, sink: &mut Q) -> f64
    where
        Q: QuirkSink<SNumberToFloatQ>,
    {
        let f = self.q_as_float(sink);
        if f.is_nan() { 0.0 } else { f }
    }
}
