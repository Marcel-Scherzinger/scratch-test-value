use std::borrow::Cow;

use crate::SValue;

impl SValue {
    pub fn is_float(&self) -> bool {
        match self {
            Self::Float(_) => true,
            Self::Int(_) => false,
            Self::Text(text) => text.contains(".") && text.parse::<f64>().is_ok(),
            Self::Bool(_) => false, // bools fit into ints
        }
    }
    pub fn is_int(&self) -> bool {
        match self {
            Self::Float(_) => false,
            Self::Int(_) => true,
            Self::Text(text) => text.parse::<i64>().is_ok(),
            Self::Bool(_) => false,
        }
    }
    pub fn is_number(&self) -> bool {
        self.is_float() || self.is_int()
    }
    #[allow(unused)]
    fn is_bool_or_bool_text(&self) -> bool {
        match self {
            Self::Bool(_) => true,
            Self::Int(_) | Self::Float(_) => false,
            Self::Text(t) => t.as_ref() == "true" || t.as_ref() == "false",
        }
    }
    /// Comparison operations (=, < and >) treat the texts `"true"` and `"false"`
    /// for comparisons differently than the boolean literals `true` and `false`
    /// that could be generated by <>-shaped-blocks.
    ///
    /// (Boolean literals `true` and `false` are equal to `1` and `0` while
    /// `"true"` and `"false"` force a textual comparison so then they are not
    /// equal to `1` and `0`.)
    ///
    /// This method is used in cases where it is not allowed to parse the
    /// string literals as booleans automatically.
    pub fn is_bool_but_not_as_text(&self) -> bool {
        matches!(self, Self::Bool(_))
    }

    pub fn as_bool(&self) -> bool {
        self.q_as_bool(&mut ())
    }

    pub fn as_text(&self) -> Cow<'_, str> {
        self.q_as_text(&mut ())
    }
    // // WARNING: for over-/underflow the behaviour is different from Scratch
    // pub fn as_int(&self) -> i64 {
    // self.q_as_int(&mut ())
    // }
    // pub fn as_float(&self) -> f64 {
    // match &self {
    // Self::Text(t) => t.parse().unwrap_or(0.0),
    // Self::Int(i) => *i as f64, // WARNING: precision loss?
    // Self::Float(f) => *f,
    // Self::Bool(true) => 1.0,
    // Self::Bool(false) => 0.0,
    // }
    // }
}
