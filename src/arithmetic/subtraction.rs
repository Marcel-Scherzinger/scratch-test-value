use crate::{
    QuirkSink, SNumber, SValue,
    quirks::{SNumberToFloatQ, SValueToNumberQ},
};

/// A subtraction of two integers would overflow/underflow so they're treated as
/// floating point numbers for subtraction, a float is then produces instead of an int.
///
/// Generated by [`SNumber::q_sub_numbers`]
pub struct IntegerSubWouldFailQ(());

impl SValue {
    /// See [`SNumber::q_sub_numbers`]
    pub fn q_sub_numbers<Q>(&self, other: &SValue, sink: &mut Q) -> SValue
    where
        Q: QuirkSink<SValueToNumberQ>
            + QuirkSink<SNumberToFloatQ>
            + QuirkSink<IntegerSubWouldFailQ>,
    {
        self.q_as_number(sink)
            .q_sub_numbers(&other.q_as_number(sink), sink)
            .svalue()
    }
}

impl SNumber {
    /// If both numbers are finite integers numbers are subtracted as integers
    /// if the result fits into an [`i64`].
    ///
    /// Otherwise, the below table applys. p and q are arbitraty finite floats.
    ///
    /// (line - column is shown in cell)
    ///
    /// | `-`   |    | `NaN` | `+∞`  | `-∞`  |  +q     |  -q     | `+0`  | `-0`  |
    /// | ----- | -- | ----- | ----- | ----- | ------- | ------- | ----- | ----- |
    /// |       |    |       |       |       |         |         |       |       |
    /// | `NaN` |    |  `0`  | `-∞`  | `+∞`  |  -q     |  +q     | `-0`  | `+0`  |
    /// | `+∞`  |    | `+∞`  | `NaN` | `+∞`  | `+∞`    | `+∞`    | `+∞`  | `-∞`  |
    /// | `-∞`  |    | `-∞`  | `-∞`  | `NaN` | `-∞`    | `-∞`    | `-∞`  | `-∞`  |
    /// |  +p   |    |  +p   | `-∞`  | `+∞`  | +p-(+q) | +p-(-q) |  +p   |  +p   |
    /// |  -p   |    |  -p   | `-∞`  | `+∞`  | -p-(+q) | -p-(-q) |  -p   |  -p   |
    /// | `+0`  |    | `+0`  | `-∞`  | `+∞`  |  -q     |  +q     |  `0`  |  `0`  |
    /// | `-0`  |    | `-0`  | `-∞`  | `+∞`  |  -q     |  +q     |  `0`  |  `0`  |
    pub fn q_sub_numbers<Q>(&self, other: &SNumber, sink: &mut Q) -> SNumber
    where
        Q: QuirkSink<SNumberToFloatQ> + QuirkSink<IntegerSubWouldFailQ>,
    {
        if let (SNumber::Int(a), SNumber::Int(b)) = (self, other) {
            if let Some(diff) = a.checked_sub(*b) {
                return SNumber::Int(diff);
            } else {
                sink.put(IntegerSubWouldFailQ(()));
            }
        }

        let a = self.q_as_float(sink);
        let b = other.q_as_float(sink);

        // NaN is treated as 0
        if a.is_nan() {
            return if b.is_nan() {
                SNumber::Int(0)
            } else {
                SNumber::Float(-b)
            };
        }
        if b.is_nan() {
            return SNumber::Float(a);
        }

        SNumber::Float(a - b)
    }
}
