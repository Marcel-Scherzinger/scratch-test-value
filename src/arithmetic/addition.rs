use crate::{
    QuirkSink, SNumber, SValue,
    quirks::{SNumberToFloatQ, SValueToNumberQ},
};

/// An addition of two integers would overflow/underflow so they're treated as
/// floating point numbers for addition, a float is then produced instead of an int.
///
/// Generated by [`SNumber::q_add_numbers`]
pub struct IntegerAddWouldFailQ(());

impl SValue {
    /// See [`SNumber::q_add_numbers`]
    pub fn q_add_numbers<Q>(&self, other: &SValue, sink: &mut Q) -> SValue
    where
        Q: QuirkSink<SValueToNumberQ>
            + QuirkSink<SNumberToFloatQ>
            + QuirkSink<IntegerAddWouldFailQ>,
    {
        self.q_as_number(sink)
            .q_add_numbers(&other.q_as_number(sink), sink)
            .svalue()
    }
}

impl SNumber {
    /// If both numbers are finite integers numbers are added as integers
    /// if the result fits into an [`i64`].
    ///
    /// Otherwise, the below table applys. p and q are arbitraty finite floats.
    ///
    /// (line + column is shown in cell)
    ///
    /// | `+`   |    | `NaN` | `+∞`  | `-∞`  |  +q     |  -q     | `+0`  | `-0`  |
    /// | ----- | -- | ----- | ----- | ----- | ------- | ------- | ----- | ----- |
    /// |       |    |       |       |       |         |         |       |       |
    /// | `NaN` |    | `0`   | `+∞`  | `-∞`  |  +q     |  -q     | `+0`  | `-0`  |
    /// | `+∞`  |    | `+∞`  | `+∞`  | `NaN` | `+∞`    | `+∞`    | `+∞`  | `-∞`  |
    /// | `-∞`  |    | `-∞`  | `NaN` | `-∞`  | `-∞`    | `-∞`    | `-∞`  | `-∞`  |
    /// |  +p   |    |  +p   | `+∞`  | `-∞`  | +p+q    | +p+(-q) |  +p   |  +p   |
    /// |  -p   |    |  -p   | `+∞`  | `-∞`  | -p+q    | -p+(-q) |  -p   |  -p   |
    /// | `+0`  |    | `+0`  | `+∞`  | `-∞`  |   +q    |  -q     |  `0`  |  `0`  |
    /// | `-0`  |    | `-0`  | `+∞`  | `-∞`  |   +q    |  -q     |  `0`  |  `0`  |
    pub fn q_add_numbers<Q>(&self, other: &SNumber, sink: &mut Q) -> SNumber
    where
        Q: QuirkSink<SNumberToFloatQ> + QuirkSink<IntegerAddWouldFailQ>,
    {
        if let (SNumber::Int(a), SNumber::Int(b)) = (self, other) {
            if let Some(sum) = a.checked_add(*b) {
                return SNumber::Int(sum);
            } else {
                sink.put(IntegerAddWouldFailQ(()));
            }
        }

        let a = self.q_as_float(sink);
        let b = other.q_as_float(sink);

        // NaN is treated as 0
        if a.is_nan() {
            return if b.is_nan() {
                SNumber::Int(0)
            } else {
                SNumber::Float(b)
            };
        }
        if b.is_nan() {
            return SNumber::Float(a);
        }

        SNumber::Float(a + b)
    }
}
