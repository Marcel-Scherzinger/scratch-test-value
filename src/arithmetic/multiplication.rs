use crate::{
    QuirkSink, SNumber, SValue,
    quirks::{SNumberToFloatQ, SValueToNumberQ},
};

/// A multiplication of two integers would overflow/underflow so they're treated as
/// floating point numbers for multiplication, a float is then produced instead of an int.
///
/// Generated by [`SNumber::q_mul_numbers`]
pub struct IntegerMulWouldFailQ(());

impl SValue {
    /// See [`SNumber::q_mul_numbers`]
    pub fn q_mul_numbers<Q>(&self, other: &SValue, sink: &mut Q) -> SValue
    where
        Q: QuirkSink<SValueToNumberQ>
            + QuirkSink<SNumberToFloatQ>
            + QuirkSink<IntegerMulWouldFailQ>,
    {
        self.q_as_number(sink)
            .q_mul_numbers(&other.q_as_number(sink), sink)
            .svalue()
    }
}

impl SNumber {
    /// If both numbers are finite integers numbers are multiplied as integers
    /// if the result fits into an [`i64`].
    ///
    /// Otherwise, the below table applys. p and q are arbitraty finite floats.
    ///
    /// (line * column is shown in cell)
    ///
    /// | `*`   |    | `NaN` | `+∞`  | `-∞`  |  +q       |  -q       | `+0`  | `-0`  |
    /// | ----- | -- | ----- | ----- | ----- | --------- | --------- | ----- | ----- |
    /// |       |    |       |       |       |           |           |       |       |
    /// | `NaN` |    | `0`   | `0`   | `0`   | `0`       | `0`       |  `0`  |  `0`  |
    /// | `+∞`  |    | `0`   | `+∞`  | `-∞`  | `+∞`      | `-∞`      | `NaN` | `NaN` |
    /// | `-∞`  |    | `0`   | `-∞`  | `+∞`  | `-∞`      | `+∞`      | `NaN` | `NaN` |
    /// |  +p   |    | `0`   | `+∞`  | `-∞`  | (+p)*(+q) | (+p)*(-q) |  `0`  |  `0`  |
    /// |  -p   |    | `0`   | `-∞`  | `+∞`  | (-p)*(+q) | (-p)*(-q) |  `0`  |  `0`  |
    /// | `+0`  |    | `0`   | `NaN` | `NaN` |  `0`      | `0`       |  `0`  |  `0`  |
    /// | `-0`  |    | `0`   | `NaN` | `NaN` |  `0`      | `0`       |  `0`  |  `0`  |
    pub fn q_mul_numbers<Q>(&self, other: &SNumber, sink: &mut Q) -> SNumber
    where
        Q: QuirkSink<SNumberToFloatQ> + QuirkSink<IntegerMulWouldFailQ>,
    {
        if let (SNumber::Int(a), SNumber::Int(b)) = (self, other) {
            if let Some(prod) = a.checked_mul(*b) {
                return SNumber::Int(prod);
            } else {
                sink.put(IntegerMulWouldFailQ(()));
            }
        }

        let a = self.q_as_float(sink);
        let b = other.q_as_float(sink);

        // NaN is treated as 0
        if a.is_nan() || b.is_nan() {
            return if a.is_infinite() || b.is_infinite() {
                SNumber::NAN
            } else {
                SNumber::Int(0)
            };
        }

        SNumber::Float(a * b)
    }
}
